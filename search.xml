<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WSL环境迁移</title>
      <link href="/2023/11/18/wsl-huan-jing-qian-yi/"/>
      <url>/2023/11/18/wsl-huan-jing-qian-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>WSL是Windows Subsystem for Linux的缩写，即“适用于Linux的Windows子系统”。它可以使Windows系统不用安装虚拟机，也不用安装双系统，只要开启了WSL功能并下载安装一个Linux分发，即可使用Linux终端和vim等常用的Linux命令与工具。这种简洁、轻量的工具一向为我所青睐，因此在Windows工作本上一直使用WSL加VSCode进行Linux环境下的Python/Fortran/C/C++/Golang开发。</p><p>最近需要在一台无法连网的Windows电脑上部署开发环境，WSL功能可以正常开启，然而Linux分发的安装上却遇到了难题，因为无论何种途径，Linux分发安装后均需要联网配置用户名和密码。后来了解到可以将连网电脑的WSL环境整体导出，再导入至不可连网的电脑中，不仅越过了Linux分发的安装问题，还省去了重新安装、配置各种工具的麻烦。在此，将WSL环境导入导出的过程以及期间遇到的问题及其解决方法进行梳理与记录。</p></blockquote><hr><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><h3 id="1-1-可连网电脑"><a href="#1-1-可连网电脑" class="headerlink" title="1.1 可连网电脑"></a>1.1 可连网电脑</h3><p>　　Windows系统版本：win11<br>　　WSL版本：1<br>　　Linux分发：Ubuntu 20.04。6 LTS</p><h3 id="1-2-不可连网电脑"><a href="#1-2-不可连网电脑" class="headerlink" title="1.2 不可连网电脑"></a>1.2 不可连网电脑</h3><p>　　Windows系统版本：win10（内部版本号低于WSL2最低安装要求）<br>　　WSL版本：1</p><h2 id="2-WSL环境导出"><a href="#2-WSL环境导出" class="headerlink" title="2. WSL环境导出"></a>2. WSL环境导出</h2><p>　　首先，列出分发，确认要导出的环境对应的分发名称，命令为在powershell中执行：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">-</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，我的连网电脑上输出如下：<br><img src="/images/WSL/wsl_l.jpg" width="300" height="100"><br>即我要导出的Linux分发名称是：Ubuntu-20.04。相应地，导出的方法为在powershell中执行：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span>export &lt;Distro&gt; &lt;FileName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，&lt;Distro&gt;为分发名称，例如上文中的“Ubuntu-20.04”。&lt;FileName&gt;为导出文件的路径和名称，例如“D:\Ubuntu-20.04.tar”。注意，导出的文件必须是“.tar”文件。导出文件的大小视WSL环境不同而不同，但一般比较大（可能有数个GB）。</p><h2 id="3-WSL环境导入"><a href="#3-WSL环境导入" class="headerlink" title="3. WSL环境导入"></a>3. WSL环境导入</h2><p>　　首先，确认要导入的电脑里是否存在与待导入分发名称相同的分发（命令：wsl -l)。若有，则或者以其他名称导入分发，或者注销已有的分发并删除相应的文件系统，命令为：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span>unregister &lt;Distro&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，&lt;Distro&gt;为待注销的分发名称。</p><p>　　从“.tar”文件中导入分发的命令为：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span>import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt; <span class="token operator">--</span>version &lt;Version&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，&lt;Distro&gt;为导入的分发名称，&lt;InstallLocation&gt;是分发导入后的安装位置，&lt;FileName&gt;是用于导入的“.tar”文件路径与名称，&lt;Version&gt;是为分发使用的WSL版本。等待一段时间后，WSL环境就导入完毕了。</p><h2 id="4-登录用户设置"><a href="#4-登录用户设置" class="headerlink" title="4. 登录用户设置"></a>4. 登录用户设置</h2><p>　　WSL环境导入后，默认以root用户登录，如下图所示：<br><img src="/images/WSL/root.jpg" width="400" height="50"><br>但以root用户登录会导致之前安装的python、gcc和go等软件或者其他工具无法正常使用，因此需要设置为以原来的用户名登录。默认用户的设置，网上很多相关的回答给出的方法都是通过“ubuntu.exe –config”命令配置默认登录用户，但该方法仅限于可以连网安装Linux分发的情况，对于导入分发的情形，根本没有“ubuntu.exe”程序。</p><p>　　对于无法连网的电脑而言，正确的方法是修改注册表。<br>　　首先，需要确认待设置用户的UID。进入导入的WSL环境，打开终端，执行如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/passwd <span class="token operator">|</span> <span class="token function">grep</span> <span class="token operator">&lt;</span>UserName<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，&lt;UserName&gt;为待设置的用户名。执行命令后，可得到类似于下图所示的输出：<br><img src="/images/WSL/passwd.jpg" width="600" height="100"><br>用户名后边的数字就是Uid，即上图中与”yorick”用户对应的Uid是1000。</p><p>　　然后，打开注册表编辑器，找到“\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Lxss\”，“Lxss”下可能有一项或多项，分别对应不同的分发，找到导入的分发所对应的项，修改“DefaultUid”的值为用户名Uid，如下图所示。注意，选中十进制后再填入Uid。<br><img src="/images/WSL/regedit.jpg" width="600" height="300"></p><p>　　注册表修改完毕后，再启动WSL终端，可以看到登录用户已不再是root。至此，完成了连网电脑中的WSL环境向不可连网电脑中迁移、配置的全部操作，在不可连网的电脑中，WSL可像原来一样使用。<br><img src="/images/WSL/yorick.jpg" width="400" height="10"></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的包检索机制分析</title>
      <link href="/2023/11/17/python-de-bao-jian-suo-ji-zhi-fen-xi/"/>
      <url>/2023/11/17/python-de-bao-jian-suo-ji-zhi-fen-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python作为一门数据模型精心设计、具有高度一致性且十分具有哲学美感的编程语言，受到不同领域人士的喜爱。其庞大且活跃的开源社区、种类丰富的第三方包以及自带的功能强大的包管理工具更是锦上添花，让使用者可以用python解决各种门类的问题。</p><p>python调用第三方包的方法十分简单，pip安装，然后在代码中import。但不知看观是否留心过，为什么python可以找到这些包，而自定义包却往往不可以直接import？而这问题的背后，就涉及到了python的包检索路径机制。在查阅了python的官方文档后，结合自己的经验和网络上其他python用户的分析，总算是大致弄清楚了python的包检索机制的来龙去脉，特此记录，留作分享与备忘。</p></blockquote><hr><p>　　对python了解稍深入的同学应该知道，执行一个py文件时，所有的包检索路径均存储于python标准库“sys”中的一个名为“sys.path”的list对象里。“sys.path”在python解释器启动之后会完成初始化，初始化之后仍可修改，用户通过向“sys.path”中append自定义包的路径的方式，使对自定义包可被python检索。后者我们暂且不关心，着重分析python解释器初始化之后，用户未修改之前，“sys.path”中存放的包检索路径从何而来。<br>　　经分析，这些路径可分为四部分，下文将安装其在“sys.path”中的存放顺序一一说明。</p><h2 id="1-脚本执行目录"><a href="#1-脚本执行目录" class="headerlink" title="1. 脚本执行目录"></a>1. 脚本执行目录</h2><p>　　“sys.path”中第一个路径是所执行的py文件所在的路径。若脚本是以交互式的方式在命令行一行一行输入执行的话，或者脚本获取自标准输入，则该路径记为空字符串。</p><h2 id="2-PYTHONPATH环境变量"><a href="#2-PYTHONPATH环境变量" class="headerlink" title="2. PYTHONPATH环境变量"></a>2. PYTHONPATH环境变量</h2><p>　　“sys.path”中第二部分路径来自PYTHONPATH环境变量中的配置的路径。这部分可以没有（即不配置PYTHONPATH环境变量），也可以有多个，而且无论路径是否有效，均会存储于“sys.path”中。不少python使用者会将自己实现的包统一放在某个路径下，然后将该路径添加到PYTHONPATH环境变量中，这样无须每次向“sys.path”append也可使自定义包被检索到。</p><h2 id="3-安装python时或创建虚拟环境时自动加入的路径"><a href="#3-安装python时或创建虚拟环境时自动加入的路径" class="headerlink" title="3. 安装python时或创建虚拟环境时自动加入的路径"></a>3. 安装python时或创建虚拟环境时自动加入的路径</h2><p>　　这一部分路径往往位于python安装路径或者虚拟环境所在的路径下。</p><h2 id="4-标准库site增加的路径"><a href="#4-标准库site增加的路径" class="headerlink" title="4. 标准库site增加的路径"></a>4. 标准库site增加的路径</h2><p>　　这第四部分是最关键，也是最晦涩的。这些路径由“site.py”控制。“site.py”是python标准库中的一个包，在python解释器初始化的时候，“site包”一般会被自动导入。除非在执行脚本时使用解释器参数“-S”（即以“python -S test.py”的形式执行py文件），才可以关闭自动导入的行为。<code>（注：此处对于导入行为的描述以及下文对site包作用的描述均基于python 3.5及以上的版本）</code><br>　　“site包”导入后，会用“头部”和“尾部”拼接出几个路径，其中，“头部”来自“sys.prefix”和“sys.exec_prefix”两个位于标准库“sys”的对象中存储的非空的路径，这些路径一般与python安装路径或者虚拟环境所在路径有关；而“尾部”则是空字符串或者具有固定形式的字符串：“lib/site-packages” (Windows系统) 或“lib/pythonX.Y/site-packages” (Unix和macOS系统，其中“X.Y”为python版本号)。<br>　　看到这里，对python和pip较熟悉的看官可能已经恍然大悟了，“site包”与“site-packages”名字上的关联已经相当说明问题，因为通过pip管理的第三方包一般都存放在某个叫做“site-packages”的文件夹里！可以猜测，site正是对site-packages路径进行检索并加入“sys.path”中，从而使第三方包可以被成功检索和导入的关键所在。<br>　　说回上文，“site包”用“头部”和“尾部”拼接出几个路径之后，会逐个判断是否为实际有效的路径，若有效，则将该路径加入“sys.path”，并尝试读取该路径下的“路径配置文件”。所谓“路径配置文件”，其实就是这些“site-packages”路径下的“.pth”文件，其中或者包含一些import命令，或者包含一些路径。前者暂且不理会，我们主要关心后者。下图所示的是我的某个python虚拟环境中“site-packages”文件夹。<br><img src="/images/py_path/site-packages.png" width="500" height="300"><br>　　从图中可以看到，site-packages下有与一般pip安装的包不同的、以“egg”结尾的包，还有几个“.pth”文件，其中“easy-install.pth”中存放的正是这些以“egg”结尾的包的相对路径，每行一个。“site包”会判断这些相对路径所对应的文件或文件夹是否存在且未被添加至“sys.path”。若满足条件，则将其转换成绝对路径添加至“sys.path”。<br><img src="/images/py_path/pth.png" width="500" height="250"><br>　　那么，这些“.egg”包有什么特别的呢？原来与直接pip下载、安装的包不同，这些包是将源代码下载到本地后在本地构建和安装的，安装后也会被放置到“site-packages”文件夹下，并且路径会写入“easy-install.pth”文件，只有这样才能被pip管理（若把某个包的路径从“easy-install.pth”中删除，则“pip list”看不到这个包的信息）。另一方面，如果希望某个路径下的包可以被检索到，除了配置PYTHONPATH环境变量、向“sys.path”append外，也可以在“site-packages”下创建一个“.pth”文件，然后将包的绝对路径写入其中。<br>　　总之，“site包”是用于使“site-packages”中的包——无论是pip直接下载安装的，还是本地生成的——可以被正确检索和导入的。感兴趣的话可以做个实验，使用解释器参数“-S”执行一个调用了通过pip安装的包的脚本，会报错“ModuleNotFoundError:”</p><hr><hr><p>　　综上所述，python解释器的包检索路径由四部分组成，其中第四部分与通过pip等方式安装的第三方包密切相关。python通过标准库“site包”对第三方包的检索路径进行了有效处理，与其强大的包管理工具相辅相成，这才令使用者方便快捷的使用众多第三方包。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器Miniconda环境搭建</title>
      <link href="/2023/11/17/fu-wu-qi-miniconda-huan-jing-da-jian/"/>
      <url>/2023/11/17/fu-wu-qi-miniconda-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Miniconda是一个python发型版，可以认为是Anaconda的轻量级版本，仅包含conda、python和二者的依赖库，以及一些常用的工具，例如pip等。前一段时间在服务器上编译的C++代码用到了C++17标准的部分特性，然而服务器上的编译器版本较老，不完全支持C++17标准，因此动了升级编译器和GDB版本的念头。</p><p>由于无root权限，无法通过服务器自带的包管理工具升级，而且服务器为多用户共用的状态，也不愿对别人造成不必要的影响，因此希望通过一个不需要root权限的包管理工具，安装较新版本的编译器以及GDB，搭建独立的python和Golang环境。</p><p>在对Homebrew与Miniconda进行综合比较之后，选择在服务器上搭建Miniconda环境。</p></blockquote><hr><h2 id="1-安装Miniconda"><a href="#1-安装Miniconda" class="headerlink" title="1. 安装Miniconda"></a>1. 安装Miniconda</h2><p>　　<a href="https://docs.conda.io/projects/miniconda/en/latest/">Miniconda官网</a>对安装方式有详细的说明。安装方式有两种。一种是通过安装程序安装，根据系统类型和硬件架构下载安装程序并运行，进行引导式安装。<br><img src="/images/Miniconda/installer.png" width="500" height="250"><br>　　另一种是通过命令行安装，执行与系统环境对应的命令行命令，快速安装Miniconda。例如，64位Linux系统下，可通过如下命令将Miniconda安装至用户home路径下的miniconda3文件夹：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/miniconda3<span class="token function">wget</span> https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh<span class="token function">bash</span> ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3<span class="token function">rm</span> -rf ~/miniconda3/miniconda.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　安装完成后，需要对其进行初始化（以终端为bash为例，对于其他终端，将命令中的bash替换即可）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">~/miniconda3/bin/conda init <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　<code>注：Miniconda也可以安装在其他路径，例如“/data/Miniconda3”，只需要将上述命令中的“~/miniconda3”替换为相应路径即可。</code></p><h2 id="2-虚拟环境设置"><a href="#2-虚拟环境设置" class="headerlink" title="2. 虚拟环境设置"></a>2. 虚拟环境设置</h2><p>　　Conda会在打开终端的时候自动进入python的base环境，可取消该设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda config --set auto_activate_base <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　若要恢复打开终端时自动进入python的base环境的设置，可在终端执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda config --set auto_activate_base <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　假如希望打开终端时自动进入指定的虚拟环境，可在“<del>/.bashrc”文件（对于其他终端，修改相应文件即可，例如zsh终端的“</del>/.zshrc”文件）的最后增加一行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda activate env_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，env_name是希望自动进入的虚拟环境的名字。保存文件后，在终端执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　附上conda创建python虚拟环境的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create -n env_name <span class="token assign-left variable">python</span><span class="token operator">=</span>num_ver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，env_name为创建的虚拟环境名称，num_ver为指定的python版本号，例如3.10。</p><h2 id="3-通过conda安装第三方工具"><a href="#3-通过conda安装第三方工具" class="headerlink" title="3. 通过conda安装第三方工具"></a>3. 通过conda安装第三方工具</h2><p>　　Miniconda环境搭建完毕以后就可以利用conda安装第三方工具了。可在<a href="https://anaconda.org/">Anaconda官网</a>检索待安装工具的信息及安装命令，以安装分布式版本控制工具git为例，流程如下：<br>　　(1) 检索git；<br><img src="/images/Miniconda/search.png" width="500" height="250"><br>　　(2) 从检索结果中寻找git；<br><img src="/images/Miniconda/git.png" width="500" height="250"><br>　　(3) 查看系统环境要求以及安装命令，执行，安装。<br><img src="/images/Miniconda/install_git.png" width="500" height="250"><br>　　附上部分常用工具的conda安装命令：<br>　　git：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　GNU make：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　cmake：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　gcc：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　g++：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge gxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　gfortran：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge gfortran<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　gdb：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge gdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　Golang：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> -c conda-forge go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>注：上述命令中的“-c conda-forge”表示指定Conda的channel为“conda-forge”。Conda不同channel的包版本有差异，且并不一定完全兼容。“conda-forge”是Conda的一个有强大社区支持、安装包种类齐全且更新及时的channel，建议均通过该channel安装。</code></p>]]></content>
      
      
      <categories>
          
          <category> conda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Miniconda </tag>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib增加字体</title>
      <link href="/2023/07/03/matplotlib-zeng-jia-zi-ti/"/>
      <url>/2023/07/03/matplotlib-zeng-jia-zi-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux服务器或者MacOS电脑上使用matplotlib画图可能会遇到图片中文乱码问题，这往往是由于缺少相应的中文字体导致的。本文将描述解决该问题的方法。</p></blockquote><hr><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>　　从matplotlib对字体的官方描述<a href="https://matplotlib.org/stable/users/explain/fonts.html">Fonts in Matplotlib</a>中可以看到，matplotlib默认字体是“DejaVu Sans”。该字体足够覆盖绝大多数欧洲语言，但是对中文支持不够，若不修改字体，画图时可能导致中文乱码。如下图所示，图片的中文标题无法正常显示：<br><img src="/images/matplotlib/title_zn.png" width="500" height="250"><br>　　要想matplotlib正常显示汉字，需要将默认字体修改为支持汉字的字体，例如“SimHei”：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltplt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'simhei'</span><span class="token punctuation">]</span> <span class="token comment">#用来正常显示中文标签</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'axes.unicode_minus'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span> <span class="token comment">#用来正常显示负号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>　　然而，上述设置生效的前提为目标字体（即上述例子中的“simhei”）存在，若不存在，则会警告改字体无法找到，字体设置也不会生效，如下图所示：<br><img src="/images/matplotlib/simhei_not_found.png" width="500" height="250"></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><h3 id="2-1-准备字体文件"><a href="#2-1-准备字体文件" class="headerlink" title="2.1 准备字体文件"></a>2.1 准备字体文件</h3><p>　　(1) 可从网上下载字体文件，也可从Windows电脑中拷贝对应的字体文件，路径一般为“C:\Windows\Fonts”，此处不予赘述;</p><p>　　(2) 将准备好的文件放入matplotlib的fonts文件夹下，该文件夹可通过执行包含如下命令的python脚本查询：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib <span class="token keyword">as</span> mpl <span class="token keyword">print</span><span class="token punctuation">(</span>mpl<span class="token punctuation">.</span>matplotlib_fname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述命令输出如下（**代表某路径）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">**/site-packages/matplotlib/mpl-data/matplotlibrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将字体文件拷贝至“mpl-data”文件夹下的“fonts/ttf”文件夹内。</p><h3 id="2-2-更新matplotlib字体缓存"><a href="#2-2-更新matplotlib字体缓存" class="headerlink" title="2.2 更新matplotlib字体缓存"></a>2.2 更新matplotlib字体缓存</h3><p>　　matplotlib的字体管理是通过其“font_manager”模块实现的，matplotlib首次被import的时候，会实例化该模块内一个名为“fontManager”的FontManager对象，该对象包含了所有可用字体的基本信息和字体的默认设置。也就是说，matplotlib可用字体完全由fontManager控制。</p><p>　　接下来是重点。</p><p>　　fontManager实例化的时候，会首先尝试读取缓存文件，缓存文件路径可通过执行包含如下命令的python脚本查询：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib <span class="token keyword">as</span> mpl <span class="token keyword">print</span><span class="token punctuation">(</span>mpl<span class="token punctuation">.</span>get_cachedir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述命令输出如下（**代表某路径）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/home/**/.cache/matplotlib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>缓存文件为上述路径下的一个json文件，该文件包含了matplotlib从系统字体文件夹里和自身字体文件夹里找到的所有字体的信息和默认设置。若该缓存文件存在，则fontManager基于缓存文件中的信息初始化；否则，matplotlib检索系统字体文件夹里和自身字体文件夹里找到的所有字体的信息，然后利用这些信息初始化，并生成缓存文件。</p><p>　　然而，一旦缓存文件存在，matplotlib就不会主动更新它，也就是说，即使将新的字体文件拷贝至字体文件夹下，新字体文件的信息并不会被写入缓存文件，该字体也就无法被matplotlib识别和使用。因此，准备好字体文件后，务必更新缓存文件。更新的方法有两个：</p><p>　　(1) 手动删除缓存文件。根据前文所述，如缓存文件不存在，matplotlib首次被import的时候，会检索系统字体文件夹里和自身字体文件夹里找到的所有字体的信息，重新生成缓存文件，新字体的信息会被写入这个新的缓存文件；</p><p>　　(2) 执行包含如下命令的python脚本：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib<span class="token punctuation">.</span>font_manager <span class="token keyword">import</span> FontManager<span class="token punctuation">,</span> json_dump<span class="token punctuation">,</span> fontManager<span class="token keyword">import</span> matplotlib <span class="token keyword">as</span> mpl<span class="token keyword">from</span> pathlib <span class="token keyword">import</span> PathfontManager <span class="token operator">=</span> FontManager<span class="token punctuation">(</span><span class="token punctuation">)</span>json_dump<span class="token punctuation">(</span>fontManager<span class="token punctuation">,</span> Path<span class="token punctuation">(</span>mpl<span class="token punctuation">.</span>get_cachedir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token string">f"fontlist-v</span><span class="token interpolation"><span class="token punctuation">{</span>FontManager<span class="token punctuation">.</span>__version__<span class="token punctuation">}</span></span><span class="token string">.json"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述命令强制重新实例化fontManager对象，该过程会重新检索系统字体文件夹里和自身字体文件夹，并将字体信息写入缓存文件，从而实现新字体的信息向缓存文件的写入。</p><h3 id="2-3-结果"><a href="#2-3-结果" class="headerlink" title="2.3 结果"></a>2.3 结果</h3><p>　　经过上述步骤，新字体得以安装并生效，画图中文乱码的问题得以完美解决。测试如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltplt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span> <span class="token comment">#用来正常显示中文标签</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'axes.unicode_minus'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span> <span class="token comment">#用来正常显示负号</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'标题'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中文标题得以正常显示：<br><img src="/images/matplotlib/title_zn_normal.png" width="500" height="250"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS常用命令备忘录</title>
      <link href="/2022/05/01/macos-commonds/"/>
      <url>/2022/05/01/macos-commonds/</url>
      
        <content type="html"><![CDATA[<h2 id="Time-Machine"><a href="#Time-Machine" class="headerlink" title="Time Machine"></a>Time Machine</h2><h3 id="1-查看本地备份快照"><a href="#1-查看本地备份快照" class="headerlink" title="1. 查看本地备份快照"></a>1. 查看本地备份快照</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmutil listlocalsnapshots <span class="token punctuation">[</span>mount_point<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　<code>mount_point</code>指的是容器（或者说是某个磁盘）。这条命令可以列出指定容器下的所有本地快照。</p><p>　　一般我们常用下面这条命令，列出<code>当前磁盘</code>的本地快照：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmutil listlocalsnapshots /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-删除本地快照"><a href="#2-删除本地快照" class="headerlink" title="2. 删除本地快照"></a>2. 删除本地快照</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tmutil deletelocalsnapshots <span class="token punctuation">{</span>mount_point <span class="token operator">|</span> date<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　如果指定<code>date</code>（格式为<code>YYYY-MM-DD-HHMMSS</code>），则删除创建于该日期的、位于所有磁盘的本地快照；如果指定<code>mount_point</code>为某个磁盘，则删除该磁盘上所有本地快照。</p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客是如何搭建的</title>
      <link href="/2022/04/28/how-to-bulid-this-blog/"/>
      <url>/2022/04/28/how-to-bulid-this-blog/</url>
      
        <content type="html"><![CDATA[<p>　　</p><blockquote><p>　　我对网页几乎可以说是一窍不通，自己摸索着搭建了这个博客，看起来好像还行，而且总共也没花多少时间，操作不是很难。因此，把搭建过程详细地描述出来，以给其他像我一样想搭建属于自己的博客的网页小白做参考。</p><p>　　如果遇到问题，欢迎在底下评论留言，或者直接联系我，我会提供力所能及的帮助。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　我的博客是用 Hexo + Github Pages 搭建的。简单说来，就是 Hexo 提供了一个博客框架，可以把我们写的类似代码一样的文件解释成漂亮的网页（当然，写歪了就会很丑），而 Github Pages 则相当于提供了展示网页的免费服务器。这样，我们只需要写“代码”（这个可以用别人写好的模板），然后把这个项目部署到 Github 上，就可以生成自己的博客了。</p><p>　　听起来不难对吧？确实是这样的，我从开始搭建，到初步生成博客，大概只花了两个小时。不过，别高兴得太早，在真正开始搭建之前，我们还需要准备一些东东，对某些人来说，它们可能比较陌生，但是一步一步来，问题不大。</p><hr><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><h3 id="1-命令行工具"><a href="#1-命令行工具" class="headerlink" title="1. 命令行工具"></a>1. 命令行工具</h3><p>　　由于在博客的搭建的过程中需要使用命令行，因此需要对命令行有一个基本的了解。</p><p>　　什么是命令行呢？不知道的同学请自行 Google一下。简单来说，命令行就是一个光秃秃的窗口（类似于大学上C语言课的时候，写完代码，打开生成的exe文件看到的那个黑洞洞的窗口），在这里可以输入一些指令，然后计算机根据指令完成相应的操作。</p><p>　　Windows 系统下主要有两个命令行工具：</p><ul><li><p>cmd<br>　　cmd 的运行方法为：按下 <code>WIN+R</code> 组合键，在打开的搜索框里输入 <code>cmd</code>，回车。<br>　　注意，cmd 默认路径是当前用户路径，因此，如果要在特定文件夹下运行命令行，需要通过 <code>cd</code> 命令切换到目标文件夹下。</p></li><li><p>powershell<br>　　powershell 则更为简单，在当前文件夹下的空白位置，按住 <code>shift</code> 键的同时点击鼠标右键，在打开的右键菜单里可以看到 <code>在当前位置打开powershell</code>，点击，即可在当前文件夹下打开 powershell。（注：Win 11 系统里，powershell 已经被添加到了右键菜单，不需要按住shift键。）</p></li></ul><p>　　而 Linux 与 Mac OS 系统下，则是 Terminal 以及许多 shell。关于命令行的使用，网上可以查到很多资料，不再赘述。</p><h3 id="2-node"><a href="#2-node" class="headerlink" title="2. node"></a>2. node</h3><p>　　如前文所述，我们需要 Hexo，而 Hexo 是基于 node.js 框架的，所以，我们需要下载 node，下载地址为：<a href="https://nodejs.org/en/">nodejs.org</a>，其官网上有详细的安装说明，包括通过 homebrew 等包管理工具下载的方法，此处不予赘述。</p><blockquote><p>注：windows系统下，安装可能稍微麻烦，可能需要自己设置好环境变量。</p></blockquote><p>　　安装完成后，在命令行中输入命令 <code>node -v</code>，该命令将显示安装的 node 版本。如果返回如下图所示，则表示安装成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">node</span> -vv18.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-Hexo"><a href="#3-Hexo" class="headerlink" title="3. Hexo"></a>3. Hexo</h3><blockquote><p>　　<a href="https://hexo.io/zh-cn/">Hexo</a> 是台湾一位大学生开发的快速、简洁且高效的博客框架。</p><p>　　现在网上有许多其他的博客框架，例如我一开始尝试使用的、也是 GitHub Pages 原生态支持的 jekyll，但是最后发现 hexo 框架可以找到更漂亮、更简洁的模板，所以最后弃用 jekyll，换用 hexo。而且相较于 jekyll，hexo对 Windows 系统的支持更加友好，这是因为 jekyll 依赖于 ruby，但是 ruby 在 Windows 下的环境配置似乎并不被推荐。</p><p>　　总之，个人感觉 hexo 比较好用，还有高颜值的模板。</p></blockquote><p>　　hexo 的下载很简单，下载好 node 之后，只需要在命令行输入如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　同样，一条命令 <code>hexo v</code> 来检验是否安装成功：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo <span class="token function">v</span>hexo-cli: <span class="token number">4.3</span>.0os: darwin <span class="token number">21.4</span>.0 <span class="token number">12.3</span>.1<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果看到类似于上图的输出，则说明安装成功。</p><h3 id="4-Github"><a href="#4-Github" class="headerlink" title="4. Github"></a>4. Github</h3><hr><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="1-博客初始化"><a href="#1-博客初始化" class="headerlink" title="1. 博客初始化"></a>1. 博客初始化</h3><p>　　现在，我们将利用安装好的 hexo 初始化一个博客，这将是我们后面更复杂更精美的博客的基础。我们将分为三步进行：</p><p><em>第一步</em>：在任意位置（例如桌面）新建一个空白文件夹，我们把这个文件夹命名为 blog</p><p>　　这个文件夹将作为博客的“大本营”，所有的文件都将放在这个文件夹下，发布新的博文也只是在这个文件夹的某个子目录里新建一个文件罢了。</p><p><em>第二步</em>：在 blog 文件夹下打开命令行，依次执行下列两条命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　命令执行完毕后，blog 文件夹里会多一些东东，如下图所示：</p><img src="/images/blog_init.png" width="500" height="250" alt="初始化后的blog文件夹"><p><em>第三步</em>：继续在命令行里依次执行以下两条命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　g表示generate，作用是利用文件夹里的文件生成静态网页。这条命令执行完毕后，blog 文件夹里会多一个“public”文件夹（里边是hexo生成的html和css等）和一个“db.json”文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　s表示server，表示在服务器上显示网页。</p><p>　　不要关闭命令行窗口，将 <a href="http://localhost:4000/">http://localhost:4000/</a> 复制到浏览器打开，我们的博客就出现了，长这样子：</p><img src="/images/localhost.png" width="800" height="600" alt="刚破壳的博客"><p>　　记住这两条命令，因为它们可以让我们在本地预览正在调试的网页（而不需要每次都把本地项目部署到Github上，并且还要再等一段时间，等Github把网页“做好了”，才能通过域名访问我们的博客）。以后修改网页的时候会经常用到这两条命令。</p><p>　　OK，经过了不懈努力，我们终于看到了“Hello, World!”，很开心对不对？不过现在最好把网页关掉，回到刚才的命令行，按下 Ctrl+C，然后把命令行也关掉，不需要依依不舍，因为后面还会经常看到它们的。</p><p>　　现在，是时候开始真正的搭建了！</p><h3 id="2-使用主题"><a href="#2-使用主题" class="headerlink" title="2. 使用主题"></a>2. 使用主题</h3><p>　　<font color="red"> 未完待续… </font></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Pages </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 常用命令备忘录</title>
      <link href="/2022/04/28/python-backup/"/>
      <url>/2022/04/28/python-backup/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将常用的python命令汇总，作为备忘录，留待日后查询使用。</p></blockquote><p><code>提示: 将不定期持续更新</code></p><hr><h2 id="一、pip命令"><a href="#一、pip命令" class="headerlink" title="一、pip命令"></a>一、pip命令</h2><h3 id="1-、安装-x2F-卸载单个包"><a href="#1-、安装-x2F-卸载单个包" class="headerlink" title="1 、安装/卸载单个包"></a>1 、安装/卸载单个包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip uninstall <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、查询可更新的包"><a href="#2、查询可更新的包" class="headerlink" title="2、查询可更新的包"></a>2、查询可更新的包</h3><p>　　下列三条命令等效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip list -O <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip list --outdated<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip-review<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>注：关于 pip-review 详见下文</code></p><h3 id="3、更新单个包"><a href="#3、更新单个包" class="headerlink" title="3、更新单个包"></a>3、更新单个包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> --upgrade <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、同时更新所有包"><a href="#4、同时更新所有包" class="headerlink" title="4、同时更新所有包"></a>4、同时更新所有包</h3><p>(1) 安装 pip-review 包，已安装请忽略该步骤；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> pip-review<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2) 执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip-review -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令可自动检索可更新的包，然后交互执行更新，即更新前会询问是否确认更新，如下图所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pip-review -i <span class="token assign-left variable">mistune</span><span class="token operator">==</span><span class="token number">2.0</span>.2 is availiable <span class="token punctuation">(</span>you have <span class="token number">0.8</span>.4<span class="token punctuation">)</span>Upgrade now? <span class="token punctuation">[</span>Y<span class="token punctuation">]</span>es, <span class="token punctuation">[</span>N<span class="token punctuation">]</span>o, <span class="token punctuation">[</span>A<span class="token punctuation">]</span>ll, <span class="token punctuation">[</span>Q<span class="token punctuation">]</span>uit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5、卸载全部包或部分包"><a href="#5、卸载全部包或部分包" class="headerlink" title="5、卸载全部包或部分包"></a>5、卸载全部包或部分包</h3><p>(1) 在某目录下，创建一个文件 pkglist.txt（名字可更换）；</p><p>(2) 在该目录下，打开命令行窗口，输入并执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip freeze <span class="token operator">&gt;</span>pkglist.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保持命令行窗口为打开状态；</p><p>(3) 此时，所有安装的第三方包名称都会保存到 pkglist.txt 文件里，编辑该文件，只保留想删除的包的名称；</p><p>(4) 回到命令行窗口，输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip uninstall -r pkglist.txt --yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可删除指定的所有包。</p><hr><h2 id="二、pip异常处理"><a href="#二、pip异常处理" class="headerlink" title="二、pip异常处理"></a>二、pip异常处理</h2><h3 id="1-No-module-named-pip"><a href="#1-No-module-named-pip" class="headerlink" title="1.No module named pip"></a>1.No module named pip</h3><p>适用于pip被误删的情况，只需依次执行如下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -m ensurepippip <span class="token function">install</span> --upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-ValueError-Unable-to-find-resource-t64-exe-in-package-pip-vendor-distlib"><a href="#2-ValueError-Unable-to-find-resource-t64-exe-in-package-pip-vendor-distlib" class="headerlink" title="2.ValueError: Unable to find resource t64.exe in package pip._vendor.distlib"></a>2.ValueError: Unable to find resource t64.exe in package pip._vendor.distlib</h3><p>执行以下命令予以解决：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -m pip uninstall setuptoolspython -m pip <span class="token function">install</span> --upgrade setuptools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="三、虚拟环境配置"><a href="#三、虚拟环境配置" class="headerlink" title="三、虚拟环境配置"></a>三、虚拟环境配置</h2><h3 id="1、virtualenv"><a href="#1、virtualenv" class="headerlink" title="1、virtualenv"></a>1、virtualenv</h3><p>(1) 安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip instal virtualenv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2) 创建虚拟环境（环境名称可任意，此处以 name 为例）</p><p>　　打开命令行窗口，切换到预选的文件夹路径，执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">virtualenv name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>注：virtualenv --no-site-packages name 可创建一个不含任何第三方包的虚拟环境，否则默认复制base环境下的所有第三方包。</code></p><p>(3) 激活环境</p><p>　　命令行里切换到虚拟环境文件夹下，例如 …\name ， 执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.<span class="token punctuation">\</span>Scripts<span class="token punctuation">\</span>activate.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>激活环境之后，用pip安装的包都将只安装在虚拟环境文件夹里；</p><p>(4) 退出环境</p><p>　　类似(3)，输入执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.<span class="token punctuation">\</span>Scripts<span class="token punctuation">\</span>deactivate.bat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注：上述内容适用于Windows系统下，Mac OS系统的虚拟环境激活命令为 </p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ./bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出虚拟环境的命令为</p>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其余一致。</p></blockquote><h3 id="2、venv"><a href="#2、venv" class="headerlink" title="2、venv"></a>2、venv</h3><p>　　python自带，不需要安装；</p><p>　　使用方法与virtualenv类似，只需将创建虚拟环境的命令修改为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python -m venv name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、-VScode中配置虚拟环境"><a href="#3、-VScode中配置虚拟环境" class="headerlink" title="3、 VScode中配置虚拟环境"></a>3、 VScode中配置虚拟环境</h3><p>　　(1) 打开VScode的设置面板，搜索“python venv path”，输入虚拟环境文件夹的路径;</p><p>　　(2) 打开一个.py文件，在左下角（或右下角）选择解释器;</p><p>　　(3) 此时虚拟环境里的解释器应该已经可以看到了。</p><blockquote><p>注：若在windows系统下的VScode终端用虚拟环境的解释器执行代码时，报错“无法加载文件 …ps1，因为在此系统上禁止运行脚本， …”，则解决方法为：</p><p>　　(1) 以管理员身份运行windows powershell；</p><p>　　(2) 执行 get-ExecutionPolicy，此时应该显示Restricted，表示状态禁止；</p><p>　　(3) 接着执行 set-ExecutionPolicy RemoteSigned.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
